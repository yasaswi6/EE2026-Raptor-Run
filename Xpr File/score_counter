`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 02.11.2024 17:40:40
// Design Name: 
// Module Name: score_counter
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module score_counter(
    input CLOCK,
    input reset,
    input start,
    output reg [3:0] an = 4'b1111,
    output reg [6:0] seg = 7'b1111111
    );
    
    reg [31:0] count = 0;
    wire clk_1hz;
    wire clk_1000hz;
    reg [3:0] digit;
    reg [1:0] current_number = 2'b00;
    
    improved_slow_clk flexi_clock(.basys_clock(CLOCK), .m(49999999), .signal(clk_1hz));
    improved_slow_clk clock2(.basys_clock(CLOCK), .m(49999), .signal(clk_1000hz));
    
    always@(posedge clk_1hz) begin
//        if(reset) begin
//            count <= 0;
//            an <= 4'b0000;
//            seg <= 7'b1000000;
            
//        end
        
        if (start == 1) begin //changed
            count <= (count == 9999) ? 0 : count + 1;
        end //changed
        else begin //changed
            count <= 0; //changed
        end //changed
    end
    
    
   
    
    
    always@(posedge clk_1000hz) begin
        
        
        case(current_number)
        
            2'b00: begin
                        digit <= (count / 10) % 10;  
                        an <= 4'b1110;     //4   
                    end
            2'b01: begin
                        digit <= (count / 100) % 10;  
                        an <= 4'b1101;           //1    
                   end
            2'b10: begin
                        digit <= (count / 1000) % 10;  
                        an <= 4'b1011;            //2    
                   end
            2'b11: begin
                        digit <= count % 10;
                        an <= 4'b0111;//3
                  end
        endcase
        
        current_number <= current_number + 1;
        
        case(digit)
            0: seg <= 7'b1000000;
            1: seg <= 7'b1111001; 
            2: seg <= 7'b0100100;
            3: seg <= 7'b0110000;
            4: seg <= 7'b0011001;
            5: seg <= 7'b0010010;
            6: seg <= 7'b0000010;
            7: seg <= 7'b1111000;
            8: seg <= 7'b0000000;
            9: seg <= 7'b0010000;
            default: seg <= 7'b1000000;
        
        endcase
        
        
    
    
    
    end
endmodule
