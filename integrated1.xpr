

module Top_Student ( // only inputs & outputs of the topmost module
                     // is to be constrained on the basys board
input basys_clock,
input btnu, btnc, btnd, btnr, btnl,
input SW_15,
output reg [6:0] seg = 7'b1111111,
output reg [3:0] an = 4'b1111,
output reg [15:0] LED,
output  [7:0] JC
);

 
 
 

wire [1:0] dino_state;
wire [15:0] oled_data;
reg [15:0] final_oled_data; // takes the input colours from the sub-modules and sends it to oled_display
wire out_6p25MHz, out_25MHz, out_1Hz, out_0p1Hz, out_30Hz, out_50Hz, out_100Hz, out_150Hz, out_200Hz;
wire w1, w2, w3;
wire btnu_debounced, btnl_debounced, btnr_debounced, btnd_debounced, btnc_debounced;
wire [12:0] pixel_index;
wire [6:0] x;
wire [5:0] y;
wire [5:0] dino_y;
wire [6:0] dino_x;
wire [1:0] state_wire;
wire [3:0] game_speed;
wire speed_increase;
wire [15:0] obstacle_data;
wire [15:0] LED_wire;
wire [15:0] background_oled;
wire [15:0] menu_data;
wire [15:0] ending_oled;
wire [3:0] counter_an;
wire [6:0] counter_seg;
wire [3:0] jump_an;
wire [6:0] jump_seg;
wire [3:0] ending_an;
wire [6:0] ending_seg;
wire [1:0] game_diff;
wire [6:0] obs_left;
wire [6:0] obs_left2;
wire [6:0] obs_right;
wire [6:0] obs_right2;
wire [5:0] obs_top;
wire [5:0] obs_bot;
wire [5:0] obs_top2;
wire [5:0] obs_bot2;
wire [6:0] dino_left;
wire [6:0] dino_right;
wire [5:0] dino_top;
wire [5:0] dino_bot;
wire hit;

reg reset = 0;
reg start = 0;
parameter frame_rate = 12;

//pixel_selecter ins5 (.x(x), .y(y), .clk_25MHz(out2), .oled_data(oled_colour) , .btnu(btnu), .btnc(btnc));

                                                   // changed from m == 8 to m == 7
improved_slow_clk clk_6p25MHz (.basys_clock(basys_clock), .m(32'd7), .signal(out_6p25MHz)); // 6.25MHz clock
improved_slow_clk clk_25MHz (.basys_clock(basys_clock), .m(32'd1), .signal(out_25MHz)); // 25MHz clock
improved_slow_clk clk_1Hz (.basys_clock(basys_clock), .m(32'd50000000), .signal(out_1Hz)); // 1Hz clock
improved_slow_clk clk_50Hz (.basys_clock(basys_clock), .m(32'd1000000), .signal(out_50Hz)); // 50Hz clk
improved_slow_clk clk_100Hz (.basys_clock(basys_clock), .m(32'd500000), .signal(out_100Hz)); // 100Hz clk
improved_slow_clk clk_200Hz (.basys_clock(basys_clock), .m(32'd250000), .signal(out_200Hz)); // 200Hz clk
improved_slow_clk clk_30Hz (.basys_clock(basys_clock), .m(1666665), .signal(out_30Hz));

improved_slow_clk clk_0p1Hz (.basys_clock(basys_clock), .m(32'd499999999), .signal(out_0p1Hz)); // 0.1Hz clk

improved_slow_clk clk_150Hz (.basys_clock(basys_clock), .m(32'd375000), .signal(out_150Hz)); // 200Hz clk

game_display dut (


   .x(x),
   .y(y),
   .dino_x(dino_x),
   .dino_y(dino_y),
   .btnd_pressed(btnd_debounced),
   .btnc_pressed(btnc_debounced),
   .clk_25MHz(out_25MHz), 
   .clk_50Hz(out_50Hz),
   .clk_100Hz(out_100Hz),
   .oled_colour(oled_data),
   .cloud_state(state_wire),
   .LED(LED),
   .dino_type(dino_state)
   
  
 ); 
 
 // assign statements 

 assign x = pixel_index % 96;
 assign y = pixel_index / 96;
 
 
 //coordinates ins (pixel_index, x, y);
 
 LED_control ins10(
 
     .clk(out_1Hz), // input a 1 Hz clock
     .LED(LED_wire)
     
     );  



Oled_Display ins3 (

.clk(out_6p25MHz), .reset(1'b0), .frame_begin(w1), .sending_pixels(w2), // oled_display takes an input clock signal of 6.25MHz
  .sample_pixel(w3), .pixel_index(pixel_index), .pixel_data(final_oled_data),
  
   .cs(JC[0]), 
   .sdin(JC[1]), 
   .sclk(JC[3]), 
   .d_cn(JC[4]), 
   .resn(JC[5]), 
   .vccen(JC[6]),
   .pmoden(JC[7])
  
  
  );

  
debouncer detect_btnu (
 .clk(out_25MHz),
 .btn(btnu), 
 .btn_stable(btnu_debounced)

);

debouncer detect_btnl (

 .clk(out_25MHz),
 .btn(btnl), 
 .btn_stable(btnl_debounced)

);

debouncer detect_btnr (

 .clk(out_25MHz),
 .btn(btnr), 
 .btn_stable(btnr_debounced)

);

debouncer detect_btnd (

 .clk(out_25MHz),
 .btn(btnd), 
 .btn_stable(btnd_debounced)

);

debouncer detect_btnc (

 .clk(out_25MHz),
 .btn(btnc), 
 .btn_stable(btnc_debounced)

);


dino_move_horizontally impliment (

    .clk(out_150Hz), // 150 Hz, can change
    .btnr_pressed(btnr_debounced), //  input is debounced btnr signal; can it also be undebounced?
    .btnl_pressed(btnl_debounced), //  input is debounced btnl signal; can it also be undebounced?
    .btnd_pressed(btnd_debounced), 
    .btnc_pressed(btnc_debounced),
    .start(start),
    .dino_x(dino_x)

);


dino_jump_vertically impl ( 

 .clk(out_150Hz), // 150Hz clk
 .pb_press(btnu_debounced), // use additional logic to avoid button debouncing    
 .dino_y(dino_y), 
 .LED(LED_wire),
 .btnd(btnd_debounced),
 .btnc(btnc_debounced)

);


random_state_gen must_work (
   .clk(out_0p1Hz), // input clk of 0.1Hz (a very slow clk)
   .state(state_wire)

);

parameter basys3_clk_freq = 100_000_000;
wire [31:0] clk_param;
assign clk_param = (basys3_clk_freq / (frame_rate)) - 1;
wire clk_frameRate;
improved_slow_clk clkframeRate (basys_clock, clk_param, clk_frameRate);

dino_menu2 DM(.CLOCK(basys_clock),.x(x), .y(y), .btnR(btnr), .btnL(btnl), .oledddd_data(menu_data), .game_diff(game_diff));
score_counter sc(.CLOCK(basys_clock), .start(start), .an(counter_an), .seg(counter_seg));

obstacle_movement obstacle_move(.clk(basys_clock),.x(x),.y(y),.obs_left(obs_left),.obs_right(obs_right),.obs_top(obs_top),.obs_bot(obs_bot),.obs_right2(obs_right2),.obs_left2(obs_left2),.obs_top2(obs_top2),.obs_bot2(obs_bot2),.game_speed(game_speed),.oled(obstacle_data),.start(start),.speed_increase(speed_increase));
speed_control speed(.clk(out_30Hz),.start(start),.speed_increase(speed_increase),.game_speed(game_speed),.game_diff(game_diff));
background_display back(.clk(out_25MHz),.oled_data (background_oled));
jump_display jumpseg(.clk(out_25MHz),.btnu_debounced(btnu_debounced), .btnd_debounced(btnd_debounced), .an(jump_an),.seg(jump_seg));
frame_data framedata (.clk(basys_clock),.frame_rate(clk_frameRate),.pixel_index(pixel_index),.oled_data(ending_oled),.an(ending_an),.seg(ending_seg));
collision_logic coll(.clk(out_25MHz),.start(start),.dino_left(dino_left),.dino_right(dino_right),.dino_top(dino_top),.dino_bot(dino_bot),.obs_left(obs_left),.obs_right(obs_right),.obs_top(obs_top),.obs_bot(obs_bot),.obs_right2(obs_right2),.obs_left2(obs_left2),.obs_top2(obs_top2),.obs_bot2(obs_bot2),.hit(hit));
dino_box dinooo(.clk(out_25MHz),.dino_state(dino_state), .dino_x(dino_x),.dino_y(dino_y),.dino_top(dino_top),.dino_bot(dino_bot),.dino_left(dino_left),.dino_right(dino_right));
// up logic
reg [1:0] state = 0; // 2-bit state for 4 states (0 to 3)
reg [31:0] counter = 0;
reg flag = 0;
reg [31:0] timer = 0;

//down logic
reg [1:0] state_D = 0; // 2-bit state for 4 states (0 to 3)
reg [31:0] counter_D = 0;
reg flag_D = 0;
reg [31:0] timer_D = 0;


reg cooldown_active = 0;          // Flag to track if cooldown is active
wire start_again;
cooldown c1 (.start(start),.clk(out_1Hz),.cooldown_active(cooldown_active),.start_again(start_again));



    reg game_over = 0;

    always @(posedge basys_clock) begin
        if(!start) begin
            an <= 4'b1111;
            seg <= 7'b1111111;
            LED <= 0;
        end
        // Start the game if center button is pressed and cooldown has ended, and not in game_over state
        if (SW_15 && !start && start_again && !game_over) begin
            start <= 1;
            game_over <= 0;  // Reset game_over when starting a new game
        end    

        // If hit occurs during gameplay, end the game and set game_over flag
        if (hit && start) begin
            start <= 0;      // Deactivate start to indicate game over
            game_over <= 1;  // Set game_over to display end screen
        end

        // OLED display control during gameplay
        if (start && !hit) begin
            LED <= LED_wire;
            if (oled_data != background_oled) begin
                final_oled_data <= oled_data;
            end          
            else if (obstacle_data != background_oled) begin
                final_oled_data <= obstacle_data;
            end  
            else begin
                final_oled_data <= background_oled;
            end

            // Display settings based on button actions
            if (btnd_debounced || btnu_debounced) begin
                an <= jump_an;
                seg <= jump_seg;
            end 
            else begin  
                an <= counter_an;
                seg <= counter_seg; 
            end
        end

        // Menu display if start is inactive and cooldown has ended
        else if (!start && start_again && !game_over) begin
            final_oled_data <= menu_data;
        end

        // End screen display if game_over is active
        else if (game_over) begin
            LED <= 0;
            final_oled_data <= ending_oled;
            an <= ending_an;
            seg <= ending_seg;

            // Wait for button press and cooldown completion to reset game and go to menu
            if ((btnc_debounced || btnu_debounced || btnd_debounced || btnl_debounced || btnr_debounced) && start_again) begin
                game_over <= 0;
                an <= 4'b1111;
                seg <= 7'b1111111;
                  // Clear game_over flag to return to menu
            end
        end
    end
endmodule


//Works: 
//always @(posedge out_25MHz) begin
//   // Edge detection on btnu_debounced
//   btnu_past <= btnu_debounced;

//   // Check if button is pressed and released (rising edge of btnu_debounced)
//   if (btnu_debounced) begin
//     counter <= (counter >= 62500) ? 0 : counter + 1;
     
//     // Update state only when counter completes a cycle for 200Hz toggle rate
//     if (counter == 0) begin
//       state <= state + 1;
//     end
     
//     // Display "PLAY" based on current state
//     case (state)
//       2'b00: begin
//         an <= 4'b0111;
//         seg <= 7'b0001100; // P
//       end
//       2'b01: begin
//         an <= 4'b1011;
//         seg <= 7'b1000111; // L
//       end
//       2'b10: begin
//         an <= 4'b1101;
//         seg <= 7'b0001000; // A
//       end
//       2'b11: begin
//         an <= 4'b1110;
//         seg <= 7'b0011001; // Y
//       end
//     endcase
     
//   end else begin // btnu is not pressed
//     // Blank display if button not pressed
//     an <= 4'b1111;
//     seg <= 7'b1111111;
////     state <= 0; // Reset state when button is released
//   end
//end

//`timescale 1ns / 1ps





//// Works (3-sec display logic:)

//`timescale 1ns / 1ps

//module Top_Student ( // only inputs & outputs of the topmost module
//                    // is to be constrained on the basys board
//input basys_clock,
//input btnu, btnc, btnd, btnr, btnl,
//output reg [6:0] seg = 7'b1111111,
//output reg [3:0] an = 4'b1111,
//output [7:0] JC
//);

 
 
//// x = pixel_index % 96
//// y = pixel_index / 96

//wire [15:0] oled_data; // takes the input colours from the sub-modules and sends it to oled_display
//wire out_6p25MHz, out_25MHz, out_100Hz, out_200Hz;
//wire w1, w2, w3;
//wire btnu_debounced, btnl_debounced, btnr_debounced, btnd_debounced, btnc_debounced;
//wire [12:0] pixel_index;
//wire [6:0] x;
//wire [5:0] y;
//wire [5:0] dino_y;
//wire [6:0] dino_x;




//coordinates ins (pixel_index, x, y);

////pixel_selecter ins5 (.x(x), .y(y), .clk_25MHz(out2), .oled_data(oled_colour) , .btnu(btnu), .btnc(btnc));

//                                                   // changed from m == 7 to m == 8
//improved_slow_clk clk_6p25MHz (.basys_clock(basys_clock), .m(32'd7), .signal(out_6p25MHz)); // 6.25MHz clock
//improved_slow_clk clk_25MHz (.basys_clock(basys_clock), .m(32'd1), .signal(out_25MHz)); // 25MHz clock
//improved_slow_clk clk_100Hz (.basys_clock(basys_clock), .m(32'd500000), .signal(out_100Hz)); // 100Hz clk
//improved_slow_clk clk_200Hz (.basys_clock(basys_clock), .m(32'd250000), .signal(out_200Hz)); // 200Hz clk



//game_display dut (

//   .x(x),
//   .y(y),
//   .dino_x(dino_x),
//   .dino_y(dino_y),
//   .btnd_pressed(btnd_debounced),
//   .btnc_pressed(btnc_debounced),
//   .clk_25MHz(out_25MHz), 
//   .clk_100Hz(out_100Hz),
//   .oled_colour(oled_data)
   
    
// );   



//Oled_Display ins3 (

//.clk(out_6p25MHz), .reset(1'b0), .frame_begin(w1), .sending_pixels(w2), // oled_display takes an input clock signal of 6.25MHz
//  .sample_pixel(w3), .pixel_index(pixel_index), .pixel_data(oled_data),
  
//   .cs(JC[0]), 
//   .sdin(JC[1]), 
//   .sclk(JC[3]), 
//   .d_cn(JC[4]), 
//   .resn(JC[5]), 
//   .vccen(JC[6]),
//   .pmoden(JC[7])
  
  
//  );

  
//debouncer detect_btnu (
// .clk(out_25MHz),
// .btn(btnu), 
// .btn_stable(btnu_debounced)

//);

//debouncer detect_btnl (

// .clk(out_25MHz),
// .btn(btnl), 
// .btn_stable(btnl_debounced)

//);

//debouncer detect_btnr (

// .clk(out_25MHz),
// .btn(btnr), 
// .btn_stable(btnr_debounced)

//);

//debouncer detect_btnd (

// .clk(out_25MHz),
// .btn(btnd), 
// .btn_stable(btnd_debounced)

//);

//debouncer detect_btnc (

// .clk(out_25MHz),
// .btn(btnc), 
// .btn_stable(btnc_debounced)

//);


//dino_move_horizontally impliment (

//    .clk(out_100Hz), // 100 Hz, can change
//    .btnr_pressed(btnr_debounced), //  input is debounced btnr signal; can it also be undebounced?
//    .btnl_pressed(btnl_debounced), //  input is debounced btnl signal; can it also be undebounced?
//    .btnd_pressed(btnd_debounced),
//    .btnc_pressed(btnc_debounced),
//    .dino_x(dino_x)

//);


//dino_jump_vertically impl ( 

// .clk(out_200Hz), // 200Hz clk
// .pb_press(btnu_debounced), // use additional logic to avoid button debouncing    
// .dino_y(dino_y)

//);

//reg [1:0] state = 0; // 2-bit state for 4 states (0 to 3)
//reg [31:0] counter = 0;
//reg flag = 0;
//reg [31:0] timer = 0;

//always @ (posedge out_25MHz) 

//begin
//   if (btnu_debounced && !flag) begin
//       flag <= 1;
//       timer <= 0;
//   end

//   if (flag) begin
//       timer <= timer + 1;
//       counter <= (counter >= 62500) ? 0 : counter + 1;
//       if (timer < 50000000) begin
//           state <= (counter == 0) ? state + 1 : state;
           
//           case (state)
//               0: begin an <= 4'b0111; seg <= 7'b0001100; end // P
//               1: begin an <= 4'b1011; seg <= 7'b1000111; end // L
//               2: begin an <= 4'b1101; seg <= 7'b0001000; end // A
//               3: begin an <= 4'b1110; seg <= 7'b0011001; end // Y
//           endcase
//       end else begin
//           flag <= 0;
//           timer <= 0;
//           an <= 4'b1111;
//           seg <= 7'b1111111;
//           state <= 0;
//       end
//   end else begin
//       an <= 4'b1111;
//       seg <= 7'b1111111;
//   end

  
//end
  
 

//endmodule
